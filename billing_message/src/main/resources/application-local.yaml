# application-local.yml
spring:
  config:
    activate:
      on-profile: local # 이 설정은 'local' 프로필일 때만 작동함
  task:
    scheduling:
      pool:
        size: 10  # 스케줄러 스레드 풀 (기본값 1 → 10)
  jpa:
    properties:
      hibernate:
        jdbc:
          batch_size: 1000
        order_inserts: true
        order_updates: true

  datasource:
    # 도커 내부(host.docker.internal)가 아니라 내 컴퓨터(localhost)로 접속
    url: jdbc:mysql://localhost:13306/billing_message
     ?rewriteBatchedStatements=true
      &useServerPrepStmts=true
      &cachePrepStmts=true
    username: ${DB_USER}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 50   # DB 작업용
      minimum-idle: 25        # 유휴 커넥션 유지

  kafka:
    # 도커 서비스명(kafka:29092)이 아니라 내 컴퓨터 포트(localhost:9092)로 접속
    bootstrap-servers: localhost:9092
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

    consumer:
      group-id: billing-message-groupM19
      auto-offset-reset: earliest
      enable-auto-commit: false # 수동 커밋 모드 (안정성 확보)
      max-poll-records: 1000     # 한 번에 가져올 메시지 양

      # [추가] Deserializer 설정 (batch 모듈과 쌍을 맞춰야 데이터가 읽힙니다)
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer

      properties:
        linger.ms: 20           # 20ms 대기 ( Throughput 향상 핵심)
        max.request.size: 5242880 # 5MB로 확장

    listener:
      # 컨슈머가 수동으로 커밋할 수 있도록 설정 (AckMode)
      ack-mode: manual_immediate
      
message:
  dispatch:
    pool-size: 500            # 배치 크기와 동일 (1배치=1초)
    queue-size: 1500
    batch-size: 500           # pool-size와 동일
    poll-delay-ms: 300        # 더 빠른 폴링
